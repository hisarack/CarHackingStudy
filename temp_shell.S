section .text
global _start

_start:
                             ; s = socket(PF_CAN, SOCK_RAW, CAN_RAW);
  push 41                    ; Socket syscall from unistd_64.h
  pop rax
  push 29                    ; PF_CAN from socket.h
  pop rdi
  push 3                     ; SOCK_RAW from socket_type.h
  pop rsi
  push 1                     ; CAN_RAW from can.h
  pop rdx
  syscall
  mov r8, rax                ; s / File descriptor from socket
                             ; strcpy(ifr.ifr_name, "vcan0");
  sub rsp, 40                ;  struct ifreq is 40 bytes
  xor r9, r9                 ; temp register to hold interface name
  mov r9, 0x306e616376       ; vcan0
  push r9
  pop qword [rsp]
                             ; ioctl(s, SIOCGIFINDEX, &ifr);
  push 16                    ; ioctrl from unistd_64.h
  pop rax
  mov rdi, r8                ; s / File descriptor
  push 0x8933                ; SIOCGIFINDEX from ioctls.h
  pop rsi
  mov rdx, rsp               ; &ifr
  syscall
  xor r9, r9                 ; clear r9
  mov r9, [rsp+16]           ; ifr.ifr_ifindex
                             ; addr.can_family = AF_CAN;
  sub rsp, 16                ; sizeof sockaddr_can
  mov word [rsp], 29         ; AF_CAN == PF_CAN
                             ; addr.can_ifindex = ifr.ifr_ifindex;
  mov [rsp+4], r9
                             ; bind(s, (struct sockaddr *)&addr,sizeof(addr));
  push 49                    ; bind from unistd_64.h
  pop rax
  mov rdi, r8                ; s /File descriptor
  mov rsi, rsp               ; &addr
  mov rdx, 16                ; sizeof(addr)
  syscall
  sub rsp, 16                ; sizeof can_frame
  mov word [rsp], 0x510      ; frame.can_id = 0x510;

  mov byte [rsp+4], 8        ;  frame.can_dlc = 8;

  mov byte [rsp+9], 0xFF     ;  frame.data[1] = 0xFF;
                             ; while(1)
loop:
                             ; write(s, &frame, sizeof(struct can_frame));
  push 1                     ; write from unistd_64.h
  pop rax
  mov rdi, r8                ; s / File descriptor
  mov rsi, rsp               ; &frame
  mov rdx, 16                ; sizeof can_frame
  syscall
                             ; usleep(500000);
  push 35                    ; nanosleep from unistd_64.h
  pop rax
  sub rsp, 16
  xor rsi, rsi
  mov [rsp], rsi             ; tv_sec
  mov dword [rsp+8], 500000  ; tv_nsec
  mov rdi, rsp
  syscall
  add rsp, 16
  jmp loop
